---
title: "Interactivity"
code-fold: true
format: 
  live-html:
    highlight-style: github
    theme:
      - cosmo
      - ../../css/site-styles.scss
      - brand
    toc: true
engine: knitr
webr:
  packages:
    - dplyr
    - palmerpenguins
    - ggplot2
    - tidyr

---

{{< include ../../_extensions/r-wasm/live/_knitr.qmd >}}

## Slides

<p style="line-height: 2.5"><a class="btn btn-success btn-sm" target="_blank" href="slides.html">{{< fa arrow-up-right-from-square >}} &ensp;Open slides in new window</a> <a class="btn btn-success btn-sm" target="_blank" href="slides.pdf" role="button">{{< fa file-pdf >}} &ensp;Download PDF of slides</a></p>

```{=html}
<div class="ratio ratio-16x9">
<iframe class="slide-deck" src="slides.html" style="border: 1px solid #343a40;"></iframe>
</div>
```

## Exercises

### {plotly} and {ggiraph}

::: {.callout-tip collapse="true"}
#### Our turn

{{< include _our-turn_plotly-ggiraph.qmd >}}
:::


### Dashboards

::: {.callout-tip collapse="true"}
#### Our turn

{{< include _our-turn_dashboards.qmd >}}
:::


### webR

::: {.callout-tip collapse="true"}
#### Our turn

{{< include _our-turn_webr.qmd >}}
:::


## Code examples

### {plotly} and {ggiraph}

Finished "our turn" code will go here


### Dashboards

Finished "our turn" code will go here


### Quarto Live

[Shiny k-means example](https://shiny.posit.co/r/gallery/start-simple/kmeans-example/)

Finished "our turn" code will go here


## Replicated Shiny example!

[Original faithful example](https://shiny.posit.co/r/gallery/start-simple/faithful/)

### With OJS

::: {.callout-warning}
This required hours of fighting with Claude and it is so janky and awful
:::

This is R code that sends the `faithful` data to OJS:

```{r}
ojs_define(faithful = faithful)
```

This is OJS code for making input options:

```{ojs}
viewof nbins = Inputs.select(
  [10, 20, 35, 50],
  {label: "Number of bins"}
)

viewof individual_obs = Inputs.checkbox(["Show individual observations"], {
  value: []
})

viewof density = Inputs.checkbox(["Show density estimate"], {
  value: []
})

viewof bw_adjust = Inputs.range([0.2, 2], {
  label: "Bandwidth adjustment:",
  step: 0.2,
  value: 1
})
```

This is OJS code for plotting the data:

```{ojs}
faithful_js = transpose(faithful)

Plot.plot({
  height: 300,
  y: { label: "Density" },
  x: { label: "Duration (minutes)" },
  marks: [
    // Probability-based histogram
    Plot.rectY(
      faithful_js,
      Plot.binX(
        { y: (bin, { x1, x2 }) => bin.length / faithful_js.length / (x2 - x1) }, // Normalize to probability density
        { x: "eruptions", thresholds: nbins } // Use nbins for threshold count
      )
    ),

    // Zero line
    Plot.ruleY([0]),

    // Individual observations
    // Individual observations (separate layer for ticks)
    individual_obs.length > 0
      ? Plot.dot(faithful_js, {
          x: "eruptions",
          y: (d) => jitter(d.eruptions, 0.05), // Deterministic jitter based on data
          // y: () => Math.random() * 0.05, // Jitter points randomly along the y-axis
          stroke: "white",
          fill: "red",
        })
      : null,

    // Density line
    density.length > 0
      ? Plot.line(
          densityEstimate(
            faithful_js.map((d) => d.eruptions),
            bw_adjust // Bandwidth adjustment
          ),
          { x: "x", y: "density", stroke: "blue" }
        )
      : null,
  ].filter((d) => d !== null),
});

// Function to compute kernel density estimate
function densityEstimate(values, bwAdjust) {
  const kde = kernelDensityEstimator(
    kernelEpanechnikov(0.2 * bwAdjust), // Kernel function
    d3.scaleLinear().domain(d3.extent(values)).ticks(200) // Evaluate KDE at 200 equally spaced points
  );
  return kde(values);
}

// Kernel density estimator function
function kernelDensityEstimator(kernel, X) {
  return function (sample) {
    return X.map((x) => ({
      x: x,
      density: d3.mean(sample, (v) => kernel(x - v)), // Adjusted scaling
    }));
  };
}

// Epanechnikov kernel function
function kernelEpanechnikov(bandwidth) {
  return function (u) {
    return Math.abs(u /= bandwidth) <= 1 ? (0.75 * (1 - u * u)) / bandwidth : 0;
  };
}

// Deterministic jitter function because Math.random() doesn't support seeds
function jitter(value, range) {
  const hash = Math.sin(value) * 10000; // Generate pseudo-random hash based on value
  return (hash - Math.floor(hash)) * range; // Scale hash to the desired range
}
```

### With webR

::: {.callout-tip}
### MAGIC

This required literally 8 minutes of reading the documentation.
:::

Here's OJS code for creating the interactive inputs:

```{ojs}
viewof nbins_r = Inputs.select(
  [10, 20, 35, 50],
  {label: "Number of bins"}
)

viewof individual_obs_r = Inputs.toggle({
  label: "Show individual observations",
  value: false
})

viewof density_r = Inputs.toggle({
  label: "Show density estimate",
  value: false
})

viewof bw_adjust_r = density_r 
  ? Inputs.range([0.2, 2], {
      label: "Bandwidth adjustment:",
      step: 0.2,
      value: 1
    })
  : html`<input type="range" value="1" style="display:none">`
```

```{webr}
#| autorun: true
#| echo: false
#| input:
#|   - nbins_r
#|   - individual_obs_r
#|   - density_r
#|   - bw_adjust_r

hist(
  faithful$eruptions,
  probability = TRUE,
  breaks = as.numeric(nbins_r),
  xlab = "Duration (minutes)",
  main = "Geyser eruption duration"
)

if (individual_obs_r) {
  rug(faithful$eruptions)
}

if (density_r) {
  dens <- density(faithful$eruptions, adjust = bw_adjust_r)
  lines(dens, col = "blue")
}
```

This is the R code for connecting to those OJS inputs and using them live:

<details>
<summary>Code</summary>

```{{webr}}
#| autorun: true
#| echo: false
#| input:
#|   - nbins_r
#|   - individual_obs_r
#|   - density_r
#|   - bw_adjust_r

hist(
  faithful$eruptions,
  probability = TRUE,
  breaks = as.numeric(nbins_r),
  xlab = "Duration (minutes)",
  main = "Geyser eruption duration"
)

if (individual_obs_r) {
  rug(faithful$eruptions)
}

if (density_r) {
  dens <- density(faithful$eruptions, adjust = bw_adjust_r)
  lines(dens, col = "blue")
}
```

<details>

## This works with ggplot too!

```{webr}
#| max-lines: 10
#| input:
#|   - species_filter
#|   - x_var
#|   - y_var
#|   - color_var
#|   - show_trend_species
#|   - show_trend_overall
penguins_filtered <- palmerpenguins::penguins |>
  filter(if (length(species_filter) > 0) species %in% species_filter else TRUE) |>
  drop_na(all_of(c(x_var, y_var)))

p <- ggplot(penguins_filtered, aes(x = .data[[x_var]], y = .data[[y_var]])) +
  geom_point(aes(color = .data[[color_var]]), size = 3, alpha = 0.7) +
  labs(
    title = "Penguins! 🐧",
    x = x_var,
    y = y_var,
    color = color_var
  ) +
  theme_minimal()

if (show_trend_species) {
  p <- p + 
    geom_smooth(
      aes(color = .data[[color_var]]), 
      method = "lm", se = FALSE, formula = 'y ~ x'
    )
}

if (show_trend_overall) {
  p <- p + 
    geom_smooth(
      color = "#FF851B", 
      method = "lm", se = FALSE, formula = 'y ~ x'
    )
}

p
```


Here's OJS code for creating the interactive inputs:

```{ojs}
numeric_vars = ["bill_length_mm", "bill_depth_mm", "flipper_length_mm", "body_mass_g"]
categorical_vars = ["species", "island", "sex"]

viewof species_filter = Inputs.checkbox(
  ["Adelie", "Chinstrap", "Gentoo"],
  {label: "Species to include", value: ["Adelie", "Chinstrap", "Gentoo"]}
)

viewof x_var = Inputs.select(numeric_vars, {
  label: "X Variable",
  value: "bill_length_mm"
})

viewof y_var = Inputs.select(numeric_vars, {
  label: "Y Variable",
  value: "bill_depth_mm"
})

viewof color_var = Inputs.select(categorical_vars, {
  label: "Color by",
  value: "species"
})

viewof show_trend_species = Inputs.toggle({
  label: "Show species trends",
  value: false
})

viewof show_trend_overall = Inputs.toggle({
  label: "Show overall trend",
  value: false
})
```
